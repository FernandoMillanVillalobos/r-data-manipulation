head(gmw)
# wide-to-long (not the best approach!)
gm <- melt(gmw, id.vars = c("country", "continent"), measure.vars = 2:37)
head(gm)
# splitting columns and casting
gm[, c("variable", "year") := tstrsplit(variable, "_", fixed = TRUE)]
gm <- dcast(gm, country + year ~ variable, value.var = c("value"))
head(gm)
# merging columns
aq <- as.data.table(airquality)
head(aq)
# creating a new column Date and mergin Month and Day into it (date format)
aq[, Date := as.Date(paste(1973, aq$Month, aq$Day, sep = "-"))]
head(aq)
# preparing the data
rev_data <- read.csv("input/sales-rev.csv", sep = ";")
weather_data <- read.csv("input/sales-weather.csv", sep = ";")
rev_data <- as.data.table(rev_data)
rev_data$DATE <- as.Date(rev_data$DATE)
weather_data <- as.data.table(weather_data)
weather_data$DATE <- as.Date(weather_data$DATE)
rev_jan <- rev_data[DATE %between% c("2020-01-01", "2020-01-31"), ]
rev_feb <- rev_data[DATE %between% c("2020-02-01", "2020-02-29"), ]
weather_jan <- weather_data[DATE %between% c("2020-01-01", "2020-01-31"), ]
str(rev_jan)
str(rev_feb)
str(weather_jan)
# with Base-R
# Join columns of datasets that # have the same rows:
cbind(rev_jan, weather_jan)
# Join rows of datasets that have # the same columns:
rbind(rev_jan, rev_feb)
# with dplyr
# Join columns of datasets that # have the same rows:
# bind_cols(rev_jan, weather_jan)
# Join rows of datasets that have # the same columns:
# bind_rows(rev_jan, rev_feb)
# merging tables using keys
# data.table
# inner join
merge(rev_data, weather_data, by = "DATE")
# Or:
# setkey(rev_data, DATE)
# rev_data[weather_data, nomatch = 0]
# # dplyr
# rev_data %>%
#   inner_join( weather_data, by = "DATE")
# outer join (left)
# data.table
merge(rev_data, weather_data, all.x = TRUE, by = "DATE")
# Or:
# setkey(weather_data, DATE)
# weather_data[rev_data]
# dplyr
# rev_data %>%
#   left_join( weather_data, by = "DATE")
# outer join (right)
# data.table
merge(rev_data, weather_data, all.y = TRUE, by = "DATE")
# Or:
# setkey(rev_data, DATE)
# rev_data[weather_data]
# dplyr
# rev_data %>%
#   right_join(weather_data, by = "DATE")
# full join
# data.table
merge(rev_data, weather_data, all = TRUE, by = "DATE")
# dplyr
# rev_data %>%
#   full_join( weather_data, by = "DATE")
# preparing the data
filter_data <- weather_data[TEMPERATURE < 0 & DATE %between% c("2020-02-01", "2020-02-29"), ]
head(filter_data)
# using a semijoin
# data.table
setkey(rev_data, DATE)
rev_data[rev_data[filter_data, which = TRUE]]
# dplyr
# rev_data %>%
#   semi_join(filter_data, by = "DATE")
# antijoin
# data.table
setkey(rev_data, DATE)
rev_data[!filter_data]
# dplyr
# rev_data %>%
#   anti_join(filter_data, by = "DATE")
# returns column index names in table format
data.frame(colnames(snowdata))
# returns row index numbers in table format
data.frame(as.integer(rownames(snowdata)))
# getting a sense of the data set
str(snowdata)
# showing the number of rows and columns...
dim(snowdata)
nrow(snowdata)
ncol(snowdata)
# ...and names
dimnames(snowdata)
rownames(snowdata)
colnames(snowdata)
# a brief statistical summary of a data set, run the summary() function
summary(snowdata)
glimpse(snowdata)
df1 <- data.frame(X = c(1, 2, 3), Y = c("a", "b", "c"), A = c(3, 4, 5))
df2 <- data.frame(X = c(1, 2, 3, 4), Y = c("A", "b", "c", "d"), Z = c("k", "l", "m", "n"), A = c("3", "4", "5", "6"))
waldo::compare(df1, df2)
# getting the first and last rows
headTail(snowdata)
# getting statistical info
Hmisc::describe(snowdata)
psych::describe(snowdata)
skim(snowdata)
# subsetting a list
simple <- list(a = c("fred", "sam", "harry"), b = c(24, 17, 19, 22))
mode(simple)
simple[2]
mode(simple[2])
simple$b
mean(simple$b)
mean(simple[[2]])
# single brackets return a list
simple[1]
# double brackets return the actual contents of selected list element
simple[[1]]
# subsetting a data frame
# First, we check the order of the columns:
data.frame(names(airquality))
airquality[5, 4]    # The 5th element from the 4th column,
# i.e. the same as airquality$Temp[5]
airquality[5,]      # The 5th row of the data
airquality[, 4]     # The 4th column of the data, like airquality$Temp
airquality[[4]]     # The 4th column of the data, like airquality$Temp
airquality[, c(2, 4, 6)] # The 2nd, 4th and 6th columns of the data
airquality[, -2]    # All columns except the 2nd one
airquality[, c("Temp", "Wind")] # The Temp and Wind columns
age <- c(28, 48, 47, 71, 22, 80, 48, 30, 31)
purchase <- c(20, 59, 2, 12, 22, 160, 34, 34, 29)
bookstore <- data.frame(age, purchase)
bookstore$age[2] <- 18
# or
bookstore[2, 1] <- 18
# subsetting with logical values
nums = c(12,9,8,14,7,16,3,2,9)
nums > 10
nums[nums > 10]
which(nums > 10)
# equal to
seq(along = nums)[nums > 10]
which.max(airquality$Temp)
airquality[which.max(airquality$Temp),]
airquality[airquality$Temp > 90, ]
# knowing if all elements in a vector fulfill the condition
all(airquality$Temp > 90)
# knowing whether at least one element in a vector fulfill the condition
any(airquality$Temp > 90)
# finding how many elements that fulfill a condition
sum(airquality$Temp > 90)
# modifying elements through logical subscriptions
nums[nums > 10] <- 0
nums
dd <- data.frame(a = c(5, 9, 12, 15, 17, 11), b = c(8, NA, 12, 10, NA, 15))
dd[dd$b > 10, ]
bookstore$visit_length <- c(5, 2, 20, 22, 12, 31, 9, 10, 11)
bookstore
# storing the TRUE or FALSE values in a new variable
airquality$Hot <- airquality$Temp > 90
airquality$Hot
# filtering and creating a new variable
temp_may <- airquality$Temp[airquality$Month == 5]
temp_june <- airquality$Temp[airquality$Month == 6]
# splitting vectors into lists
temps <- split(airquality$Temp, airquality$Month)
names(temps) <- c("May", "June", "July", "August", "September")
temps
temps$June
# collapsing lists into vectors
unlist(temps)
# using subset
subset(dd, b > 10)
some <- subset(LifeCycleSavings, sr > 10, select = c(pop15, pop75))
head(some)
life1 <- subset(LifeCycleSavings, select = pop15:dpi)
# or
life1 <- subset(LifeCycleSavings, select = 1:3)
head(life1)
life2 <- subset(LifeCycleSavings, select = c(-pop15, -pop75))
# or
life2 <- subset(LifeCycleSavings, select = -c(2, 3))
head(life2)
# sorting with sort()
w <- c(5, 4, 7, 2, 7, 1)
sort(w)
sort(w, decreasing = TRUE)
length(w) <- 7
sort(w, na.last = TRUE)
sort(w, na.last = FALSE)
# using order() to sort a data frame
v <- c(11, 12, 13, 15, 14)
order(v)
v[order(v)]
u <- c("pig", "cow", "duck", "horse", "rat")
w <- data.frame(v, u)
w
w[order(w$v), ]
snowdata[order(snowdata$SnowInches), ]
snowdata[order(snowdata$SnowInches, snowdata$SnowMeters), ]
# getting the location of the maximum and minimum values
which.max(snowdata$Boston)
which.min(snowdata$Boston)
snowdata <- rio::import("input/BostonChicagoNYCSnowfalls.csv")
# knowing how may rows
snowdata[nrow(snowdata), ]
# using filter from dplyr
filter(snowdata, Boston > 100)
# OR
filter(snowdata, Boston < 20 | Boston > 100)
# AND
filter(snowdata, Boston > 40 & Boston < 50)
filter(snowdata, Boston > 50, Boston < 80)
# using slice()
myresults <- slice(snowdata, 60:76)
# arranging data frames
# ascending order
arrange(snowdata, Boston)
# descencing order
arrange(snowdata, desc(Boston))
# by a second column
arrange(snowdata, Boston, NYC)
# selecting columns
select(snowdata, Winter, Boston)
select(snowdata, Boston:NYC)
select(snowdata, contains("C"))
select(snowdata, ends_with("C"))
select(snowdata, -ends_with("C"))
snowdata_numeric <- select_if(snowdata, is.numeric)
psych::describe(snowdata_numeric)
# subsetting by row and column numbers
lastrow <- nrow(snowdata)
snowdata[lastrow, ]
# one line of code gives you the same exact result as another
identical(snowdata[76,], snowdata[lastrow,])
# getting the lowest and the highest value
range(snowdata$Boston)
# pulling the row from snowdata that has the lowest Boston winter snow total
slice(snowdata, which.min(Boston))
# tidyselect
# relocating columns with everything()
mpg %>%
select(manufacturer, cyl, everything()) %>%
glimpse()
# selecting the last column
mpg %>%
select(last_col()) %>%
glimpse()
# selecting all columns except the last one
mpg %>%
select(!last_col()) %>%
glimpse()
# you can use last_col to select the n-to-last column
mpg %>%
select(last_col(1)) %>%
glimpse()
# select all columns that start with the letter “m”
mpg %>%
select(starts_with("m")) %>%
glimpse()
mpg %>%
select(ends_with(c("l", "r"))) %>%
glimpse()
# selecting columns that contain certain strings
mpg %>%
select(contains("m")) %>%
glimpse()
mpg %>%
rename(Manufacturer = manufacturer) %>%
select(contains("m", ignore.case = FALSE)) %>%
glimpse()
# selecting all columns that contain a number
billboard %>%
select(matches("\\d")) %>%
colnames()
billboard %>%
select(matches("wk\\d{1}$")) %>%
colnames()
anscombe %>%
select(matches("[xy][1-2]")) %>%
glimpse()
# selecting columns with number ranges
anscombe %>%
select(num_range("x", 1:2)) %>%
glimpse()
billboard %>%
select(num_range("wk", 1:15)) %>%
glimpse()
# selecting columns of a specific type
billboard %>%
select(where(is.character)) %>%
glimpse()
# combining selections
mpg %>%
select(where(is.character) & contains("l")) %>%
glimpse()
mpg %>%
select(where(is.character) | contains("l")) %>%
glimpse()
aq <- as.data.table(airquality)
# modifying a variable
# data.table
aq[, Wind := Wind * 0.44704]
# dplyr
aq %>% mutate(Wind = Wind * 0.44704) -> aq
# computing a new variable based on existing variables
# data.table
aq[, Hot := Temp > 90]
# dplyr
aq %>% mutate(Hot = Temp > 90) -> aq
# renaming a variable
# data.table
setnames(aq, "Hot", "HotDay")
# dplyr
# aq %>% rename(HotDay = Hot) -> aq
# removing a variable
# data.table
aq[, HotDay := NULL]
aq[, c("Month", "Day") := NULL] # multiple cols
# dplyr
# aq %>% select(-HotDay) -> aq
# aq %>% select(-Month, -Day) -> aq # multiple cols
# chaining commands
# data.table
aq[, Month := nafill(Month, "locf")][, .N, Month]
aq <- as.data.table(airquality)
# modifying a variable
# data.table
aq[, Wind := Wind * 0.44704]
# dplyr
aq %>% mutate(Wind = Wind * 0.44704) -> aq
# computing a new variable based on existing variables
# data.table
aq[, Hot := Temp > 90]
# dplyr
aq %>% mutate(Hot = Temp > 90) -> aq
# renaming a variable
# data.table
setnames(aq, "Hot", "HotDay")
# dplyr
# aq %>% rename(HotDay = Hot) -> aq
# removing a variable
# data.table
aq[, HotDay := NULL]
aq[, c("Month", "Day") := NULL] # multiple cols
# dplyr
# aq %>% select(-HotDay) -> aq
# aq %>% select(-Month, -Day) -> aq # multiple cols
# chaining commands
# data.table
aq <- as.data.table(airquality)
aq[, Month := nafill(Month, "locf")][, .N, Month]
# dplyr
aq %>%
fill(Month) %>%
group_by(Month, across(days = n()))
# realoading the data
aq <- as.data.table(airquality)
# filtering using row numbers
# data.table
aq[3, ]
aq[3:5, ]
aq[c(3, 7, 15), ]
aq[-c(3, 7, 15), ]
# dplyr
aq %>% slice(3)
aq %>% slice(3:5)
aq %>% slice(c(3, 7, 15))
aq %>% slice(-c(3, 7, 15))
# filtering using conditions
# data.table
aq[Temp > 90, ]
aq[Month == 6, ]
aq[Temp > 90 & Month == 6, ]
aq[Temp %between% c(80, 90), ]
aq[frankv(-Temp,
ties.method = "min"
) <= 5, ]
unique(aq) # removing duplicate rows
na.omit(aq) # removing rows with missing data
na.omit(aq, "Ozone") # removing rows with missing Ozone values
# dplyr
aq %>% filter(Temp > 90)
aq %>% filter(Month == 6)
aq %>% filter(
Temp > 90,
Month == 6
)
aq %>% filter(between(
Temp,
80, 90
))
aq %>% top_n(5, Temp)
aq %>% distinct # removing duplicate rows
aq %>% drop_na # removing rows with missing data
aq %>% drop_na("Ozone") # removing rows with missing Ozone values
# selecting rows at random
# data.table
aq[sample(.N, 5), ]
# dplyr
aq %>% sample_n(5)
# using regular expressions to select rows
dogs <- data.table(
Name = c(
"Bianca", "Bella", "Mimmi", "Daisy",
"Ernst", "Smulan"
),
Breed = c(
"Greyhound", "Greyhound", "Pug", "Poodle",
"Bedlington Terrier", "Boxer"
),
Desc = c(
"Fast, playful", "Fast, easily worried",
"Intense, small, loud",
"Majestic, protective, playful",
"Playful, relaxed",
"Loving, cuddly, playful"
)
)
# data.table
dogs[Name %like% "^B", ]
# or:
dogs[grepl("^B", Name), ]
dogs[Desc %like% "[pP]layful", ]
# dplyr
dogs %>% filter(grepl("B[a-z]", Name))
dogs %>% filter(grepl("[pP]layful", Desc))
# selecting a single column
# data.table
# Return a vector:
aq$Temp
# or
aq[, Temp]
# Return a data.table:
aq[, "Temp"]
aq[, .(Temp, Month, Day)]
aq[, Wind:Month]
aq[, -c("Month", "Day")]
aq[, sapply(msleep, class) == "numeric"] # selecting all numeric variables
aq[, .SD, .SDcols = colSums(is.na(aq)) == 0] # removing cols with missing values
# dplyr
# Return a vector:
aq$Temp
# or
aq %>% pull(Temp)
# Return a tibble:
aq %>% select(Temp)
aq %>% select(Temp, Month, Day)
aq %>% select(Wind:Month)
aq %>% select(-Month, -Day)
aq %>% select_if(is.numeric)
aq %>% select_if(~all(!is.na(.)))
# using regular expressions to select columns
# data.table
vars <- grepl("n", names(aq))
aq[, ..vars]
# dplyr
# contains is a convenience
# function for checking if a name
# contains a string:
aq %>% select(contains("n"))
# matches can be used with any
# regular expression:
aq %>% select(matches("n"))
# subsetting using columns numbers
# using column numbers can yield different results depending on what type of data table you’re using
aq <- as.data.frame(airquality)
str(aq[,2])
# data.table:
aq <- as.data.table(airquality)
str(aq[,2])
# tibble:
aq <- as_tibble(airquality)
str(aq[,2])
# aq[[2]]  works the same for data frames, data tables and tibbles, returning a vector
aq <- as.data.frame(airquality)
str(aq[[2]])
# data.table:
aq <- as.data.table(airquality)
str(aq[[2]])
# tibble:
aq <- as_tibble(airquality)
str(aq[[2]])
# changing the column order
# data.table
setcolorder(aq, c("Month", "Day"))
# dplyr
aq %>% relocate("Month", "Day")
# changing row order
# sorting a single vector
aq <- data.table(airquality)
sort(aq$Wind)
sort(aq$Wind, decreasing = TRUE)
sort(c("C", "B", "A", "D"))
# data.table
aq[order(Wind), ] # ascending order
aq[order(-Wind), ] # descending order
aq[order(Temp, -Wind), ]
# dplyr
aq %>% arrange(Wind) # ascending order
aq %>% arrange(-Wind) # descending order
# or
aq %>% arrange(desc(Wind))
aq %>% arrange(Temp, desc(Wind))
