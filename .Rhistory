nums
dd <- data.frame(a = c(5, 9, 12, 15, 17, 11), b = c(8, NA, 12, 10, NA, 15))
dd[dd$b > 10, ]
bookstore$visit_length <- c(5, 2, 20, 22, 12, 31, 9, 10, 11)
bookstore
# storing the TRUE or FALSE values in a new variable
airquality$Hot <- airquality$Temp > 90
airquality$Hot
# filtering and creating a new variable
temp_may <- airquality$Temp[airquality$Month == 5]
temp_june <- airquality$Temp[airquality$Month == 6]
# splitting vectors into lists
temps <- split(airquality$Temp, airquality$Month)
names(temps) <- c("May", "June", "July", "August", "September")
temps
temps$June
# collapsing lists into vectors
unlist(temps)
# using subset
subset(dd, b > 10)
some <- subset(LifeCycleSavings, sr > 10, select = c(pop15, pop75))
head(some)
life1 <- subset(LifeCycleSavings, select = pop15:dpi)
# or
life1 <- subset(LifeCycleSavings, select = 1:3)
head(life1)
life2 <- subset(LifeCycleSavings, select = c(-pop15, -pop75))
# or
life2 <- subset(LifeCycleSavings, select = -c(2, 3))
head(life2)
# sorting with sort()
w <- c(5, 4, 7, 2, 7, 1)
sort(w)
sort(w, decreasing = TRUE)
length(w) <- 7
sort(w, na.last = TRUE)
sort(w, na.last = FALSE)
# using order() to sort a data frame
v <- c(11, 12, 13, 15, 14)
order(v)
v[order(v)]
u <- c("pig", "cow", "duck", "horse", "rat")
w <- data.frame(v, u)
w
w[order(w$v), ]
snowdata[order(snowdata$SnowInches), ]
snowdata[order(snowdata$SnowInches, snowdata$SnowMeters), ]
# getting the location of the maximum and minimum values
which.max(snowdata$Boston)
which.min(snowdata$Boston)
# using indexes on the rows and/or columns
rows <- Arthritis$Sex == "Female" & Arthritis$Age > 68
cols <- c("Treatment", "Improved")
Arthritis[rows, cols]
# using names of values of a column to subset and create a new variable (no data)
# btw9s[c("BB", "BE", "MV","SN","ST","TH"), "EW"] <- "East"
# creating new variables based on others and reordering (no data)
# Fleiss93 <- within(Fleiss93, {
#   total <- n.e + n.c # create new var based on the sum of two
#   st1 <- as.character(study) # change type
#   st <- reorder(study, -(total)) # reorder var
# })
# fixing the naming (no data)
# exp1_long$condition <- ifelse(exp1_long$condition == "no", "No_communication",
#   ifelse(exp1_long$condition == "go", "High_confidence",
#     ifelse(exp1_long$condition == "me", "Medium_confidence",
#       ifelse(exp1_long$condition == "ba", "Low_confidence",
#         exp1_long$condition
#       )
#     )
#   )
# )
# renaming variables and convert to numeric (no data)
# exp1_long$temperature <- as.numeric(ifelse(exp1_long$temperature == "315", "31.5",
#   ifelse(exp1_long$temperature == "325", "32.5",
#     ifelse(exp1_long$temperature == "335", "33.5",
#       ifelse(exp1_long$temperature == "345", "34.5",
#         ifelse(exp1_long$temperature == "355", "35.5",
#           ifelse(exp1_long$temperature == "365", "36.5",
#             exp1_long$temperature
#           )
#         )
#       )
#     )
#   )
# ))
# recoding Yes/No responses as numeric (Yes=1, No=0) (no data)
# exp1_long$response_code <- ifelse(exp1_long$response == "Yes", 1, 0)
# adding values by row and getting rid of all NAs (no data)
# df.a$expertise_sum <- rowSums(df.a[, 12:19], na.rm = TRUE)
# cutting numeric variables into categories
age <- c(60, 58, 24, 26, 34, 42, 31, 30, 33, 2, 9)
age.breaks <- seq(from = 0, to = 60, by = 20)
age.labels <- c("young", "adult", "older")
age.group <- cut(x = age, breaks = age.breaks, labels = age.labels)
age.df <- data.frame(age, age.group)
age.df
# creating a temporal seq of years and calculate mean (no data)
# yrs <- c(seq(1972, 1988, 4), 1993, seq(1996, 2016, 4)) # seq every 4 years
# Calculating mean for every year
# mean_age <- gss_lon %>%
#   filter(age %nin% NA && year %in% yrs) %>%
#   group_by(year) %>%
#   summarize(xbar = round(mean(age, na.rm = TRUE), 0))
# splitting a vector by group (no data)
# using split function: x = the variable that needs to be split into groups; y = the grouping variable
# speech.by.char <- split(x = utterance, y = speaker)
# speech.by.char
# pull variables from a list or data frame out and into the workspace
# importList(speech.by.char)
# locating NAs in a data frame
# pos_country <- which(is.na(df$Region))
# replacing NAs in a data frame for the last value with na.locf() (no data)
# replacing NAs for the last value
# df <- mutate(df, Region = zoo::na.locf(Region))
snowdata <- rio::import("input/BostonChicagoNYCSnowfalls.csv")
# knowing how may rows
snowdata[nrow(snowdata), ]
# using filter from dplyr
filter(snowdata, Boston > 100)
# OR
filter(snowdata, Boston < 20 | Boston > 100)
# AND
filter(snowdata, Boston > 40 & Boston < 50)
filter(snowdata, Boston > 50, Boston < 80)
# using slice()
myresults <- slice(snowdata, 60:76)
# arranging data frames
# ascending order
arrange(snowdata, Boston)
# descencing order
arrange(snowdata, desc(Boston))
# by a second column
arrange(snowdata, Boston, NYC)
# selecting columns
select(snowdata, Winter, Boston)
select(snowdata, Boston:NYC)
select(snowdata, contains("C"))
select(snowdata, ends_with("C"))
select(snowdata, -ends_with("C"))
snowdata_numeric <- select_if(snowdata, is.numeric)
psych::describe(snowdata_numeric)
# subsetting by row and column numbers
lastrow <- nrow(snowdata)
snowdata[lastrow, ]
# one line of code gives you the same exact result as another
identical(snowdata[76,], snowdata[lastrow,])
# getting the lowest and the highest value
range(snowdata$Boston)
# pulling the row from snowdata that has the lowest Boston winter snow total
slice(snowdata, which.min(Boston))
# tidyselect
# relocating columns with everything()
mpg %>%
select(manufacturer, cyl, everything()) %>%
glimpse()
# selecting the last column
mpg %>%
select(last_col()) %>%
glimpse()
# selecting all columns except the last one
mpg %>%
select(!last_col()) %>%
glimpse()
# you can use last_col to select the n-to-last column
mpg %>%
select(last_col(1)) %>%
glimpse()
# select all columns that start with the letter “m”
mpg %>%
select(starts_with("m")) %>%
glimpse()
mpg %>%
select(ends_with(c("l", "r"))) %>%
glimpse()
# selecting columns that contain certain strings
mpg %>%
select(contains("m")) %>%
glimpse()
mpg %>%
rename(Manufacturer = manufacturer) %>%
select(contains("m", ignore.case = FALSE)) %>%
glimpse()
# selecting all columns that contain a number
billboard %>%
select(matches("\\d")) %>%
colnames()
billboard %>%
select(matches("wk\\d{1}$")) %>%
colnames()
anscombe %>%
select(matches("[xy][1-2]")) %>%
glimpse()
# selecting columns with number ranges
anscombe %>%
select(num_range("x", 1:2)) %>%
glimpse()
billboard %>%
select(num_range("wk", 1:15)) %>%
glimpse()
# selecting columns of a specific type
billboard %>%
select(where(is.character)) %>%
glimpse()
# combining selections
mpg %>%
select(where(is.character) & contains("l")) %>%
glimpse()
mpg %>%
select(where(is.character) | contains("l")) %>%
glimpse()
aq <- as.data.table(airquality)
# modifying a variable
# data.table
aq[, Wind := Wind * 0.44704]
# dplyr
aq %>% mutate(Wind = Wind * 0.44704) -> aq
# computing a new variable based on existing variables
# data.table
aq[, Hot := Temp > 90]
# dplyr
aq %>% mutate(Hot = Temp > 90) -> aq
# renaming a variable
# data.table
setnames(aq, "Hot", "HotDay")
# dplyr
# aq %>% rename(HotDay = Hot) -> aq
# removing a variable
# data.table
aq[, HotDay := NULL]
aq[, c("Month", "Day") := NULL] # multiple cols
# dplyr
# aq %>% select(-HotDay) -> aq
# aq %>% select(-Month, -Day) -> aq # multiple cols
# chaining commands
# data.table
aq <- as.data.table(airquality)
aq[, Month := nafill(Month, "locf")][, .N, Month]
# dplyr
aq %>%
fill(Month) %>%
group_by(Month, across(days = n()))
# realoading the data
aq <- as.data.table(airquality)
# filtering using row numbers
# data.table
aq[3, ]
aq[3:5, ]
aq[c(3, 7, 15), ]
aq[-c(3, 7, 15), ]
# dplyr
aq %>% slice(3)
aq %>% slice(3:5)
aq %>% slice(c(3, 7, 15))
aq %>% slice(-c(3, 7, 15))
# filtering using conditions
# data.table
aq[Temp > 90, ]
aq[Month == 6, ]
aq[Temp > 90 & Month == 6, ]
aq[Temp %between% c(80, 90), ]
aq[frankv(-Temp,
ties.method = "min"
) <= 5, ]
unique(aq) # removing duplicate rows
na.omit(aq) # removing rows with missing data
na.omit(aq, "Ozone") # removing rows with missing Ozone values
# dplyr
aq %>% filter(Temp > 90)
aq %>% filter(Month == 6)
aq %>% filter(
Temp > 90,
Month == 6
)
aq %>% filter(between(
Temp,
80, 90
))
aq %>% top_n(5, Temp)
aq %>% distinct # removing duplicate rows
aq %>% drop_na # removing rows with missing data
aq %>% drop_na("Ozone") # removing rows with missing Ozone values
# selecting rows at random
# data.table
aq[sample(.N, 5), ]
# dplyr
aq %>% sample_n(5)
# using regular expressions to select rows
dogs <- data.table(
Name = c(
"Bianca", "Bella", "Mimmi", "Daisy",
"Ernst", "Smulan"
),
Breed = c(
"Greyhound", "Greyhound", "Pug", "Poodle",
"Bedlington Terrier", "Boxer"
),
Desc = c(
"Fast, playful", "Fast, easily worried",
"Intense, small, loud",
"Majestic, protective, playful",
"Playful, relaxed",
"Loving, cuddly, playful"
)
)
# data.table
dogs[Name %like% "^B", ]
# or:
dogs[grepl("^B", Name), ]
dogs[Desc %like% "[pP]layful", ]
# dplyr
dogs %>% filter(grepl("B[a-z]", Name))
dogs %>% filter(grepl("[pP]layful", Desc))
# selecting a single column
# data.table
# Return a vector:
aq$Temp
# or
aq[, Temp]
# Return a data.table:
aq[, "Temp"]
aq[, .(Temp, Month, Day)]
aq[, Wind:Month]
aq[, -c("Month", "Day")]
aq[, sapply(msleep, class) == "numeric"] # selecting all numeric variables
aq[, .SD, .SDcols = colSums(is.na(aq)) == 0] # removing cols with missing values
# dplyr
# Return a vector:
aq$Temp
# or
aq %>% pull(Temp)
# Return a tibble:
aq %>% select(Temp)
aq %>% select(Temp, Month, Day)
aq %>% select(Wind:Month)
aq %>% select(-Month, -Day)
aq %>% select_if(is.numeric)
aq %>% select_if(~all(!is.na(.)))
# using regular expressions to select columns
# data.table
vars <- grepl("n", names(aq))
aq[, ..vars]
# dplyr
# contains is a convenience
# function for checking if a name
# contains a string:
aq %>% select(contains("n"))
# matches can be used with any
# regular expression:
aq %>% select(matches("n"))
# subsetting using columns numbers
# using column numbers can yield different results depending on what type of data table you"re using
aq <- as.data.frame(airquality)
str(aq[,2])
# data.table:
aq <- as.data.table(airquality)
str(aq[,2])
# tibble:
aq <- as_tibble(airquality)
str(aq[,2])
# aq[[2]]  works the same for data frames, data tables and tibbles, returning a vector
aq <- as.data.frame(airquality)
str(aq[[2]])
# data.table:
aq <- as.data.table(airquality)
str(aq[[2]])
# tibble:
aq <- as_tibble(airquality)
str(aq[[2]])
# changing the column order
# data.table
setcolorder(aq, c("Month", "Day"))
# dplyr
aq %>% relocate("Month", "Day")
# changing row order
# sorting a single vector
aq <- data.table(airquality)
sort(aq$Wind)
sort(aq$Wind, decreasing = TRUE)
sort(c("C", "B", "A", "D"))
# data.table
aq[order(Wind), ] # ascending order
aq[order(-Wind), ] # descending order
aq[order(Temp, -Wind), ]
# dplyr
aq %>% arrange(Wind) # ascending order
aq %>% arrange(-Wind) # descending order
# or
aq %>% arrange(desc(Wind))
aq %>% arrange(Temp, desc(Wind))
# filling in missing values
aq$Month[c(2:3, 36:39, 70)] <- NA
# data.table
aq[, Month := data.table::nafill(Month, "locf")] # fill the missing values with the last non-missing entry
aq[, Month := nafill(Month, "nocb")] # fill the missing values with the next non-missing entry
# dplyr
aq %>% fill(Month) -> aq
aq %>% fill(Month, .direction = "up") -> aq
# finding the lengths of the names of the states of USA
nchar(state.name)
# using cat function
x = 7
y = 10
cat("x should be greater than y, but x=',x,' and y=',y,' x should be greater than y, but x = 7 and y = 10")
# with fill argument
cat("Long strings can", "be displayed over", "several lines using", "the fill= argument", fill = 40)
# using paste
paste("one", 2, "three", 4, "five")
paste(c("one", "two", "three", "four"), collapse = " ")
paste(c("X", "Y"), 1:5, sep = "")
paste(c("X", "Y"), 1:5, sep = "_", collapse = "|")
paste(c("X", "Y"), 1:5, sep = "_") # with space -> no collapse argument
# working with parts of character values
substring(state.name, 2, 6)
# finding location of particular characters
state <- "Mississippi"
ll <- nchar(state)
ltrs <- substring(state, 1:ll, 1:ll)
ltrs
which(ltrs == "s")
# regular expressions
expr <- ".*\\.txt"
nchar(expr)
cat(expr, "\n")
sentence = "R is a free software environment for statistical computing"
parts = strsplit(sentence," ")
parts
# lintr::lint("main.Rmd", linters =
#               lintr::with_defaults(
#                 commented_code_linter = NULL,
#                 trailing_whitespace_linter = NULL
#                 )
#             )
# if you have additional scripts and want them to be linted too, add them here
# lintr::lint("scripts/my_script.R")
styler:::style_selection()
parts
parts <- strsplit(sentence, " ")
parts
length(parts)
length(parts[[1]])
sapply(parts, length)
allparts <- unlist(parts)
allparts
strsplit(str,’ +’)
strsplit(str," +")
strsplit(parts," +")
styler:::style_selection()
str <- "one two three four"
strsplit(parts, " +")
strsplit(str, " +")
# using regex
grep(’^pop’,names(LifeCycleSavings))
# using regex
grep("^pop",names(LifeCycleSavings))
grep("^pop",names(LifeCycleSavings), value = TRUE)
styler:::style_selection()
styler:::style_selection()
# creating a data frame using grep as argument
head(LifeCycleSavings[, grep("^pop", names(LifeCycleSavings))])
styler:::style_selection()
styler:::style_selection()
styler:::style_selection()
grep("\\<dog\\>", inp, ignore.case = TRUE)
inp <- c("run dog run", "work doggedly", "CAT AND DOG")
grep("\\<dog\\>", inp, ignore.case = TRUE)
styler:::style_selection()
any(grep("profit", str1))
str1 <- c("The R Foundation", "is a not for profit organization", "working in the public interest")
str2 <- c(" It was founded by the members", "of the R Core Team in order", "to provide support for the R project")
any(grep("profit", str1))
any(grep("profit", str2))
styler:::style_selection()
tst <- c("one x7 two b1", "three c5 four b9", "five six seven", "a8 eight nine")
wh <- regexpr("[a-z][0-9]", tst)
wh
attr(,"match.length")
wh
styler:::style_selection()
styler:::style_selection()
res <- substring(tst, wh, wh + attr(wh, "match.length") - 1)
res
styler:::style_selection()
wh1 <- gregexpr("[a-z][0-9]", tst)
wh1
styler:::style_selection()
res1 = list()
for (i in 1:length(wh1)) {
res1[[i]] <- substring(
tst[i], wh1[[i]],
wh1[[i]] +
attr(wh1[[i]], "match.length") - 1
)
}
res1
styler:::style_selection()
# substitutions
values <- c("$11,317.35", "$11,234.51", "$11,275.89", "$11,278.93", "$11,294.94")
as.numeric(gsub("[$,]","",values))
styler:::style_selection()
styler:::style_selection()
values <- c("75.99", "(20.30)", "55.20")
as.numeric(gsub("\\(([0-9.]+)\\)", "-\\1", values))
styler:::style_selection()
styler:::style_selection()
styler:::style_selection()
styler:::style_selection()
str <- "report: 17 value=12 time=2:00"
sub("value=([^ ]+)", "\\1", str)
styler:::style_selection()
styler:::style_selection()
sub("^.*value=([^ ]+).*$", "\\1", str)
